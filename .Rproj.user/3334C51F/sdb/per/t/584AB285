{
    "collab_server" : "",
    "contents" : "# Get distance matrix in a long form with \n# averaged distances to kNN for both end-points\nget_dist_df <- function(D, K = NULL) {\n  N <- nrow(D)\n  rownames(D) <- colnames(D) <- 1:N\n  distDF <- reshape2::melt(D)\n  colnames(distDF) <- c(\"j\", \"i\", \"d\")\n  distDF <- distDF[distDF$i < distDF$j, ]\n  # Compute average distance to kNN\n  dkNN <- kNN_dist(D, K = K)\n  distDF$i_sigma_K <- dkNN$mean[distDF$i]\n  distDF$j_sigma_K <- dkNN$mean[distDF$j]\n  distDF$max_sigma_K <- pmax(distDF$i_sigma_K, distDF$j_sigma_K)\n  distDF$min_sigma_K <- pmin(distDF$i_sigma_K, distDF$j_sigma_K)\n  return(distDF)\n}\n\n\n# Fit Bayesian Unidimensional Scaling model to\n# obtain observations ordering estimates\nfit_buds <- function(D, K = NULL, stan_file = \"./src/buds.stan\",\n                     init_from = c(\"random\", \"principal_curve\"),\n                     seed = NULL,\n                     hyperparams = list(\n                       \"tau_shape1\" = 1,\n                       \"tau_shape2\"= 1,\n                       \"gamma_epsilon\" = 2.5, \n                       \"gamma_bias\" = 2.5,\n                       \"gamma_rho_sq\" = 2.5,\n                       \"min_sigma\" = 0.001), max_trials = 20) {\n  rstan_options(auto_write = TRUE)\n  options(mc.cores = parallel::detectCores())\n  \n  # Convert D matrix to long form and get kNN distances\n  distDF <- get_dist_df(D, K = K)\n  \n  # Compute weights for observations\n  weights <- distDF$min_sigma_K\n  weights <- weights/max(weights) \n  weights <- pmax(weights, rep(0.1, length(weights)))\n  \n  dist_data <- list(\n    \"N\" = ncol(D),\n    \"Npairs\" = length(distDF$i),\n    \"i_idx\" = distDF$i,\n    \"j_idx\" = distDF$j,\n    \"dvec\" = distDF$d,\n    \"weight\" = weights\n  ) \n  stan_data <- modifyList(hyperparams, dist_data)\n  \n  init <- match.arg(init_from, c(\"random\", \"principal_curve\"))\n  if (init == \"principal_curve\") {\n    tau0 <- prin_curve_loc(D)\n    offset <- 1e-3   \n    tau0 <- (tau0 - min(tau0) + offset) / (max(tau0) - min(tau0) + 2*offset)\n    init <- list(\"tau\" = tau0, \"bias\" = offset, \"rho_sq\" = 1.0, \n                 \"mean_var\" = 0.05)\n  } \n  if(!is.numeric(seed)) seed <- sample.int(.Machine$integer.max, 1)\n  while(max_trials > 0) {\n    fit <-try(rstan::vb(stan_model(stan_file), data = stan_data, init = init,\n                        seed = seed))\n    if(class(fit) != \"try-error\") break\n    max_trials <- max_trials - 1\n    seed <- sample.int(.Machine$integer.max, 1)\n  }\n  return(list(fit_buds = fit, seed = seed, distDF = distDF, weights = weights))\n}\n\n# Select nkeep samples evenly spaced along the [0, 1] tau interval\nget_subset_tau <- function(tau, nkeep) {\n  if(is.null(names(tau))) names(tau) <- 1:length(tau)\n  tau <- sort(tau)\n  idx <- sapply(seq(min(tau), max(tau), length.out = nkeep), \n                function(x) sum(tau >= x))\n  idx <- length(tau) - idx + 1\n  return(names(tau)[idx])\n}\n\n# Extract BUDS tau parameter into data frame \nget_tau_df <- function(buds_fit, prob = 0.95) {\n  fitParams <- rstan::extract(buds_fit)\n  tau_mcmc <- coda::mcmc(fitParams$tau)\n  tau_mode <- MCMCglmm::posterior.mode(tau_mcmc)\n  tau_intv <- HPDinterval(tau_mcmc, prob = prob)\n  resdf <- data.frame(tau = tau_mode,\n                      tau_lower = tau_intv[, 1], \n                      tau_upper = tau_intv[, 2])\n  return(resdf)\n}",
    "created" : 1493015153354.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2020478231",
    "id" : "584AB285",
    "lastKnownWriteTime" : 1493015169,
    "last_content_update" : 1493015169937,
    "path" : "~/MEGA/BIOSTATS GROUP/Projects/visBUDS/visTrajectory/R/model.R",
    "project_path" : "R/model.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}