{
    "collab_server" : "",
    "contents" : "#' Data subset along gradient\n#' \n#' Select a subset of samples evenly spaced along\n#' the underlying gradient using the latent coordinates\n#' for the data points on a [0, 1] interval. \n#' \n#' @param tau A numeric vector representing the latent \n#' positions of data points.\n#' @param nkeep An integer indicating the number of samples\n#' to keep.\n#' \n#' @return A vector with names of selected samples. \n#' @export\nget_subset_tau <- function(tau, nkeep) {\n  if(is.null(names(tau))) names(tau) <- 1:length(tau)\n  tau <- sort(tau)\n  idx <- sapply(seq(min(tau), max(tau), length.out = nkeep), \n                function(x) sum(tau >= x))\n  idx <- length(tau) - idx + 1\n  return(names(tau)[idx])\n}\n\n\n#' Extract tau\n#'  \n#' Extracts tau parameter from the BUDS fit object. Computes\n#' the mode and upper and lower highes posterior density \n#' interval. \n#' \n#' @param buds_fit A stanfit object from fit_buds() output.\n#' @param prob [Optional] A fraction for the probability of HPD interval.\n#' Default is 0.95.\n#' \n#' @return A data frame with columns corresponding\n#' to mode tau estimates and the lower and upper HPD.\n#' \n#' @export\nget_tau_df <- function(buds_fit, prob = 0.95) {\n  fitParams <- rstan::extract(buds_fit)\n  tau_mcmc <- coda::mcmc(fitParams$tau)\n  tau_mode <- MCMCglmm::posterior.mode(tau_mcmc)\n  tau_intv <- HPDinterval(tau_mcmc, prob = prob)\n  resdf <- data.frame(tau = tau_mode,\n                      tau_lower = tau_intv[, 1], \n                      tau_upper = tau_intv[, 2])\n  return(resdf)\n}\n\n#' Low dimensional data representation.\n#' Compute reduced representations of the data.\n#' A wrapper for cmdscale and Rtsne::Rtsne()\n#' \n#' @param D A pairwise dissimilarity matrix.\n#' @param method [Optional] A dimensionality reduction\n#' method either \"PCoA\" or \"tSNE\". Default is \"PCoA\".\n#' @param dims [Optional] An integer for the number of dimensions\n#' for to keep. Default is 2.\n#' @param ... other parameters for Rtsne::Rtsne() function\n#' \n#' @return A data frame with the low-dimensional \n#' represenation.\n#' \n#' @export\nlow_dim_vis <- function(D, method = \"PCoA\", dims = 2, ...){\n  if(is.null(rownames(D))) {\n    if (is.null(colnames(D))) {\n      rownames(D) <- colnames(D) <- 1:nrow(D)\n    } else {\n      rownames(D) <- colnames(D)\n    }\n  }\n  method <- match.arg(method, c(\"PCoA\", \"tSNE\"))\n  if(!(method %in% c(\"PCoA\", \"tSNE\"))) {\n    stop(\"Only PCoA and tSNE visualizations are now supported.\")\n  }\n  if (!(dims > ncol(D))) {\n    stop(\"dims cannot be larger than the number of observations.\")\n  }\n  eigs_percent <- NULL\n  if (method == \"PCoA\") {\n    pcoa_res <- cmdscale(sqrt(D), k = dims, eig = TRUE)\n    eigs_percent <- signif(100 * pcoa_res$eig /sum(pcoa_res$eig), digits = 3)\n    Y <- data.frame(pcoa_res$points)\n  } else {\n    perpl <- 30\n    if (nrow(D) - 1 < 3 * perpl) perpl <- floor((nrow(D) - 1)/3)\n    tsne_res <- Rtsne::Rtsne(D, dims = dims, is_distance = TRUE, pca = FALSE,\n                             perplexity = perpl, ...)\n    Y <- data.frame(tsne_res$Y)\n  }\n  colnames(Y) <- paste0(\"D\", 1:dims)\n  return(list(Y=Y, eigs = eigs_percent))\n}\n\n#' Posterior samples of noisy dissimilarities\n#'  \n#' Generate copies of noisy dissimilarity matrices\n#' according to the estimates of latent coordinates\n#' and the BUDS model.\n#' \n#' @param D A pairwise dissimilarity matrix.\n#' @param buds_fit A stanfit object from fit_buds() output.\n#' @param B An integer for the number of copies of D to \n#' generate.\n#' \n#' @return A list of two list: one with posterior draws of noisy\n#' dissimilarities, booD, and one of corresponding posterior \n#' tau estimates bootTau.\n#' \n#' @export\nget_D_copies <- function(D, buds_fit, B) {\n  fitParams <- rstan::extract(buds_fit)\n  n <- dim(fitParams$tau)[2]\n  if(B > dim(fitParams$tau)[1]) {\n    B <- dim(fitParams$tau)[1]\n  }\n  D.lst <- lapply(1:B, function(i) {\n    delta.mat <- fitParams$bias[i] + fitParams$rho_sq[i] *\n      as.matrix(dist(fitParams$tau[i, ]))\n    idelta <- delta.mat[lower.tri(delta.mat)]\n    sig_sq <- (1e-3 +  fitParams$meanvar[i]) * \n      (1e-2 +  D[lower.tri(D)]^2) + 1e-3\n    alpha <- idelta^2/sig_sq\n    beta <- idelta/sig_sq\n    idvec <- sapply(1:length(idelta), function(k)\n      rgamma(1, shape = alpha[k], rate = beta[k]))\n    iD <- matrix(0, nrow = n, ncol = n)\n    iD[lower.tri(iD)] <- idvec\n    iD <- iD + t(iD);\n    return(iD)\n  })\n  tau.lst <- as.list(data.frame(t(fitParams$tau[1:B, ])))\n  return(list(D.lst = D.lst, tau.lst = tau.lst))\n}\n\n\n#' Get data in a format for DiSTATIS\n#'  \n#' @param D A pairwise dissimilarity matrix.\n#' @param D.lst A list of posterior noisy dissimilarity draws.\n#' @param tau_mode [Optional] A mode estimate of tau.\n#' @param tau.lst  [Optional] A list of tau posterior draws \n#' correspodning to each element of D.lst.\n#' @param covariate  [Optional] A vector with a sample\n#' covariate of interest.\n#' \n#' @return A list with a 3D dissimilarity array, bootD,\n#' and a list of data frames booData for each\n#' slice of bootD and a data frame modeData \n#' @export\nget_input_for_distatis <- function(D, D.lst, \n                                   tau_mode = NA,\n                                   tau.lst = NULL, \n                                   covariate = NA) {\n  if(!is.null(tau.lst) & (length(D.lst) != length(tau.lst))) {\n    stop(\"Length of tau.lst and D.lst must match.\")\n  }\n  if(length(covariate) != ncol(D) | length(tau_mode) != ncol(D)) {\n    stop(\"Length of covariate and tau_mode and ncol(D) must match.\")\n  }\n  B <- length(D.lst)\n  n <- ncol(D)\n  if(is.null(tau.lst)) tau.lst <- rep(NA, B)\n  # 3D array for DiSTATIS\n  D.arr <- array(0, dim=c(n, n, B + 1))\n  D.arr[, , 1] <- D\n  for(i in 1:B){\n    D.arr[, , i+1] <- D.lst[[i]]\n  }\n  # Corresponding tau data \n  data.lst <- lapply(1:B, function(i) {\n   data.frame(tau = tau.lst[[i]], \n              rank_tau = rank(tau.lst[[i]], ties.method = \"first\"),\n              covariate = covariate) \n  })\n  mode_data <- data.frame(tau = tau_mode, \n                          rank_tau = rank(tau_mode, ties.method = \"first\"),\n                          covariate = covariate) \n  data.lst <- c(list(mode_data), data.lst)\n  return(list(bootD = D.arr, booData.lst = data.lst, modeData = mode_data))\n}\n\n\n#' Distatis ordination coordiantes\n#'  \n#' Compute ordination coordinates for all copies\n#' of D using a three-way MDS method, DiSTATIS.\n#' \n#' @param bootD A 3D array with posterior dissimilarity samples.\n#' @param dims An integer for the number of dimensions for\n#' DiSTATIS.\n#' @param booData.lst [Optional] A list of length equal dim(bootD)[3]\n#' containing data frames corresponding to bootD slices.\n#' @param modeData [Optional] A sample data frame for consensus\n#' configuration.\n#' \n#' @return A list with two data frames: partial for DiSTATIS\n#' configurations for each slice of bootD separately,\n#' and consensus with an \"average\" configuration.\n#' \n#' @export\nrun_distatis <- function(bootD, dims = 2, \n                         booData.lst = NULL,\n                         modeData = NULL) {\n  if(!is.null(booData.lst) & (length(booData.lst) != dim(bootD)[3])) {\n    stop(\"Length of booData.lst and dim(bootD)[3] must match.\")\n  }\n  if(dim(bootD)[1] != dim(bootD)[2]) {\n    stop(\"bootD must be a 3D array [n x n x B] contating B\n         square matrices.\")\n  }\n  # Number of data points\n  n <- dim(bootD)[1]\n  B <- dim(bootD)[3]\n  \n  # Compute DiSTATIS representation\n  fit_distatis <- DistatisR::distatis(bootD, nfact2keep = dims)\n  # Collect configurations for each D in bootD and for \n  distatis_coords <- fit_distatis$res4Splus[[\"PartialF\"]]\n  distatis_df <- plyr::alply(distatis_coords, 3)\n  distatis_df <- lapply(1:length(distatis_df), function(i) {\n    data.frame(SampleID = 1:n, booData.lst[[i]], distatis_df[[i]])\n  })\n  names(distatis_df) <- 1:length(distatis_df) - 1\n  distatis_df <- plyr::ldply(distatis_df)\n  \n  # Consensus coordinates\n  consensus_coords <- fit_distatis$res4Splus[[\"F\"]]\n  consensus_df <- data.frame(SampleID = 1:n, \n                             modeData, consensus_coords)\n  return(list(partial = distatis_df, consensus = consensus_df))\n}",
    "created" : 1493015098047.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1402465222",
    "id" : "173A5D20",
    "lastKnownWriteTime" : 1492991169,
    "last_content_update" : 1492991169,
    "path" : "~/MEGA/BIOSTATS GROUP/Projects/visBUDS/R/get_data_to_plot.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}