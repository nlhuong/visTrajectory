{
    "collab_server" : "",
    "contents" : "# Compute correlation distance\ncor_dist <- function(X, log_trans = TRUE, scale = TRUE, base = 1e6){\n  if(scale) { # scale samples to the same base level\n    X <- apply(X, 2, function(x) x/sum(x)*base)\n  }\n  \n  if (log_trans) { # log-transform data\n    logexp <- log10(X + 1) \n  }\n  # Compute correlation based distance\n  corDist <- (1 - cor(X, method = \"pearson\"))/2\n  D <- as.matrix(corDist) \n  return(D)\n}\n\n# Compute Jaccard distance\njacc_dist <- function(X, min_row_sum = 100, min_row_prevalence = 5){\n  X <- X[rowSums(X > 0) >= min_row_prevalence, ]\n  X <- X[rowSums(X) >= min_row_sum, ]\n  jaccDist <- dist(t(X), method = \"binary\")\n  D <- as.matrix(jaccDist) \n  return(D)\n}\n\n# Rank based transform distances to triangular distribution\ntransform_dist <- function(D) {\n  # Transform distances to match triangular distribution\n  dvec0 <- D[lower.tri(D)]\n  dvec <- rank(dvec0)\n  dvec <- dvec/max(dvec)\n  dvec <- 1 - sqrt(1 - dvec)\n  D <- matrix(0, nrow = nrow(D), ncol = ncol(D))\n  D[lower.tri(D)] <- dvec\n  D <- D + t(D)\n  return(D)\n}\n\n# Distance to kNN\nkNN_dist <- function(D, K = NULL) {\n  if (is.null(K) || is.na(K)) K <- floor(ncol(D)/10)\n  D_kSort <- apply(D, 2, function(x) {sort(x)})\n  mean <- apply(D_kSort, 2, function(x){\n    mean(x[2:(K+1)]) \n  })\n  var <- apply(D_kSort, 2, function(x){\n    var(x[2:(K+1)]) \n  })\n  return(list(mean = mean, var = var))\n}\n\n\n# Get 1D principal curve locations\nprin_curve_loc <- function(D, ...) {\n  pcoa_res <- cmdscale(sqrt(D), k = 2, eig = TRUE)\n  X <- as.matrix(pcoa_res$points)\n  prin_curve <- princurve::principal.curve(X, plot = FALSE, ...)\n  tau <- prin_curve$lambda \n  tau <- (tau - min(tau))/(max(tau) - min(tau))\n  return(tau)  \n}\n\n\n\n\nlow_dim_vis <- function(D, method = \"PCoA\", dims = 2, ...){\n  if(is.null(rownames(D))) {\n    if (is.null(colnames(D))) {\n      rownames(D) <- colnames(D) <- 1:nrow(D)\n    } else {\n      rownames(D) <- colnames(D)\n    }\n  }\n  method <- match.arg(method, c(\"PCoA\", \"tSNE\"))\n  if(!(method %in% c(\"PCoA\", \"tSNE\"))) {\n    stop(\"Only PCoA and tSNE visualizations are now supported.\")\n  }\n  if (!(dims %in% c(2, 3))) {\n    stop(\"Only 2D or 3D plots are are now supported.\")\n  }\n  if (method == \"PCoA\") {\n    pcoa_res <- cmdscale(sqrt(D), k = dims, eig = TRUE)\n    eigs_percent <- signif(100 * pcoa_res$eig /sum(pcoa_res$eig), digits = 3)\n    Y <- data.frame(pcoa_res$points)\n  } else {\n    perpl <- 30\n    if (nrow(D) - 1 < 3 * perpl) perpl <- floor((nrow(D) - 1)/3)\n    tsne_res <- Rtsne::Rtsne(D, dims = dims, is_distance = TRUE, pca = FALSE,\n                             perplexity = perpl, ...)\n    Y <- data.frame(tsne_res$Y)\n  }\n  colnames(Y) <- paste0(\"D\", 1:dims)\n  return(Y)\n}\n\n# Generate noisy dissimilarities according to the model\nget_D_copies <- function(D, buds_fit, B) {\n  fitParams <- rstan::extract(buds_fit)\n  n <- dim(fitParams$tau)[2]\n  if(B > dim(fitParams$tau)[1]) {\n    B <- dim(fitParams$tau)[1]\n  }\n  \n  D.lst <- lapply(1:B, function(i) {\n    delta.mat <- fitParams$bias[i] + fitParams$rho_sq[i] *\n      as.matrix(dist(fitParams$tau[i, ]))\n    idelta <- delta.mat[lower.tri(delta.mat)]\n    sig_sq <- (1e-3 +  fitParams$meanvar[i]) * (1e-2 +  D[lower.tri(D)]^2) + 1e-3\n    alpha <- idelta^2/sig_sq\n    beta <- idelta/sig_sq\n    idvec <- sapply(1:length(idelta), function(k)\n      rgamma(1, shape = alpha[k], rate = beta[k]))\n    iD <- matrix(0, nrow = n, ncol = n)\n    iD[lower.tri(iD)] <- idvec\n    iD <- iD + t(iD);\n    return(iD)\n  })\n  D.arr <- array(0, dim=c(n, n, B + 1))\n  D.arr[, , 1] <- D\n  for(i in 1:B){\n    D.arr[, , i+1] <- D.lst[[i]]\n  }\n  return(D.arr)\n}\n\n\n# Get Distatis three-way ordination coordinates\nrun_distatis <- function(D, bootD, buds_fit, tau_mode, covariate = NA) {\n  fitParams <- rstan::extract(buds_fit)\n  n <- dim(fitParams$tau)[2]\n  fit_distatis <- DistatisR::distatis(bootD, nfact2keep = 2)\n  # Distatis separate coords sets  \n  distatis_coords <- fit_distatis$res4Splus[[\"PartialF\"]]\n  distatis_df <- plyr::alply(distatis_coords, 3)\n  distatis_df <- lapply(1:length(distatis_df), function(i) {\n    if(i > 1) {\n      data.frame(SampleID = 1:n, covariate = covariate,\n                 rank_tau = rank(fitParams$tau[i-1, ], ties.method = \"first\"),\n                 tau = fitParams$tau[i-1, ], distatis_df[[i]])\n    } else {\n      data.frame(SampleID = 1:n, covariate = covariate,\n                 rank_tau = rank(tau_mode, ties.method = \"first\"),\n                 tau = tau_mode, distatis_df[[1]])\n    }\n    \n  })\n  names(distatis_df) <- 1:length(distatis_df) - 1\n  distatis_df <- plyr::ldply(distatis_df)\n  \n  # Consensus coordinates\n  consensus_coords <- fit_distatis$res4Splus[[\"F\"]]\n  consensus_df <- data.frame(SampleID = 1:n, covariate = covariate,\n                             rank_tau = rank(tau_mode, ties.method = \"first\"),\n                             tau = tau_mode, consensus_coords)\n  \n  return(list(partial = distatis_df, consensus = consensus_df))\n}\n\n## ----- plot functions -----\n\n# Plot distance to kNN\nplot_kNN_mean_dist <- function(D, tau, color = \"blue\", color_label = \"Covariate\", \n                               K = NULL, error_bars = FALSE) {\n  dkNN <- kNN_dist(D, K = K)\n  df <- data.frame(tau = tau, col = color,\n                   kNN_dist_mean = dkNN$mean, \n                   kNN_dist_sd = sqrt(dkNN$var))\n  plt <- ggplot(df, aes(x = tau, y = kNN_dist_mean, fill = col, color = col)) +\n    geom_point(size = 3, color = \"grey77\", pch = 21) + \n    scale_fill_viridis(name = color_label, discrete = !(is.numeric(color))) + \n    scale_color_viridis(name = color_label, discrete = !(is.numeric(color))) + \n    ylab(\"Distance to kNN\")\n  if(error_bars) {\n    plt <- plt + geom_errorbar(aes(ymin = kNN_dist_mean - kNN_dist_sd,\n                                   ymax = kNN_dist_mean + kNN_dist_sd))\n  }\n  return(plt)\n}\n\n# Plot buds 1D coordinates against their ranking \n# or selected covariate from sample data \nplot_buds_1D <- function(tau_df, covariate = NULL, covariate_name = \"covariate\", \n                         color = \"blue\", color_label = NULL, idxBigger = NULL) {\n  if(!all(c(\"tau\", \"tau_lower\", \"tau_upper\") %in% colnames(tau_df))) {\n    stop(\"'tau_df' must have columns c('tau', 'tau_lower', 'tau_upper') specified.\")\n  }\n  if(is.null(covariate)){\n    tau_df$x <- rank(tau_df$tau)\n  } else {\n    tau_df$x <- rank(covariate)\n  }\n  tau_df$color <- color\n  name_x_axis <- ifelse(is.null(covariate), \"rank(tau)\",\n                        paste0(\"rank(\", covariate_name, \")\"))\n  plt <- ggplot(tau_df, aes(x = x, y = tau, color = color)) +\n    geom_errorbar(aes(ymin = tau_lower, ymax = tau_upper), \n                  lwd = 0.7) +\n    geom_point(aes(fill = color), color = \"grey77\", pch = 21, size = 2) +\n    scale_color_viridis(name = color_label, discrete = (!is.numeric(color))) +\n    scale_fill_viridis(name = color_label, discrete = (!is.numeric(color))) +\n    xlab(name_x_axis) + ylab(\"tau\") \n  \n  if(!is.null(idxBigger)) {\n    plt <- plt + \n      geom_point(data = tau_df[idxBigger, ], aes(fill = color), \n                 color = \"grey77\", pch = 21, size = 5)\n  }\n  return(plt)\n}\n\n\n# Plot BUDS trajectory in 2D\nplot_buds_trajectory <- function(Y, buds_fit,\n                                 sample_data = NULL, covariate_name = \"covariate\", \n                                 path_col = \"#2171B5\", nPaths = 50, nCenters = 30){\n  color_data <- \"black\"\n  if (!is.null(sample_data)){\n    if (!(covariate_name %in% colnames(sample_data))) {\n      stop(\"covariate_name is not a column in sample_data supplied.\")\n    } else {\n      color_data <- sample_data[, covariate_name]\n    }\n  }\n  # Extract tau parameter\n  fitParams <- rstan::extract(buds_fit)\n  tau_mcmc <- coda::mcmc(fitParams$tau)\n  tau_mode <- MCMCglmm::posterior.mode(tau_mcmc)\n  names(tau_mode) <- rownames(D)\n  tau_samples <- fitParams$tau\n  tau_samples <- tau_samples[sample(1:nrow(tau_samples), nPaths), ]\n  \n  eigs_percent <- NULL\n  \n  # Data to plot\n  DF <- Y\n  colnames(DF) <- paste0(\"D\", 1:ncol(Y))\n  if(!is.null(sample_data)) DF <- cbind(DF, sample_data, \n                                        color_data = color_data)\n  modeDF <- data.frame(tau_mode = tau_mode, DF)\n  modeDF <- modeDF[order(tau_mode), ]\n  # Pick a subset of samples \n  idx <- seq(1, length(tau_mode), length.out = nCenters) #get_subset_tau(tau_mode, nCenters)\n  modeDF <- modeDF[idx, ]\n  trajDF <- lapply(1:nrow(tau_samples), function(i) {\n    data.frame(trajectory = i,  Y[order(tau_samples[i, ]), ])\n  })\n  trajDF <- do.call(\"rbind\", trajDF)\n  \n  if (ncol(Y) == 2) {\n    plt <- ggplot(trajDF, aes(D1, D2)) + \n      geom_path(aes(group = trajectory), color = path_col, alpha = 0.1) +\n      geom_path(data = modeDF, color = \"grey17\", lwd = 1.2) +\n      geom_point(data = DF, color = \"grey77\", pch = 21, size = 2,\n                 aes(fill = color_data)) +\n      geom_point(data = modeDF, color = \"grey77\", pch = 21, size = 4,\n                 aes(fill = color_data)) +\n      scale_fill_viridis(name = covariate_name, \n                         discrete = !(is.numeric(color_data)))\n    if (!is.null(eigs_percent)){\n      plt <- plt + xlab(paste0(\"PC1 [\", eigs_percent[1], \"%]\")) +\n        ylab(paste0(\"PC2 [\", eigs_percent[2], \"%]\")) + \n        coord_fixed(ratio = max(0.5, eigs_percent[2]/eigs_percent[1]))\n    }  \n  } else if (ncol(Y) > 2) {\n    plt <- plot_ly(type = 'scatter3d', mode = 'lines+markers', colors = viridis_pal(option = \"A\")(9)) %>%\n      add_trace(x = modeDF$D1, y = modeDF$D2, z = modeDF$D3,\n                color = modeDF$color_data, marker = list(size = 3), line = list(width = 2)) %>%\n      add_markers(x = DF$D1, y = DF$D2, z = DF$D3, marker = list(size = 1),\n                  color = DF$color_data, mode = \"markers\")\n    if (!is.null(eigs_percent)){\n      plt <- plt %>% \n        layout(xaxis = list(title = paste0(\"PC1 [\", eigs_percent[1], \"%]\")), \n               yaxis = list(title = paste0(\"PC2 [\", eigs_percent[2], \"%]\"))) \n    }  \n  }\n  return(plt)\n}\n\n# Plot ordered data matrix\nplot_ordered_matrix <- function(X, tau, log_trans = FALSE,\n                                keep_fatures = NULL, nfeatures = 500,\n                                byMean = TRUE, window = NULL, \n                                minSum = 100){\n  X <- X[rowSums(X) > minSum, ]\n  if(is.null(window)) window <- floor(ncol(X)/10)\n  \n  nfeatures <- min(nfeatures, 2*ncol(X))\n  if(is.null(keep_fatures)) keep_fatures <- sample(1:nrow(X), nfeatures)\n  nSamples <- ncol(X)\n  X2plot <- X[keep_fatures, order(tau)]\n  \n  normX2plot <- apply(X2plot, 2, function(x) x/sum(x))\n  \n  if(byMean) {\n    feat_loc <- normX2plot %*% tau\n  } else {\n    feat_loc <- apply(normX2plot, 1, function(x) {\n      x <- c(x)\n      y <- cumsum(x)[window:nSamples] - c(0, cumsum(x)[1:(nSamples - window)]) \n      which.max(y)\n    })\n  }\n  X2plot <- X2plot[order(feat_loc), ] \n  rownames(X2plot) <- colnames(X2plot) <- NULL\n  \n  if(log_trans) X2plot <- as.matrix(X2plot) + 1 \n  plt <- plot_matrix(X2plot) + coord_fixed() +\n    xlab(\"Samples\") + ylab(\"Features\") +\n    theme(axis.text.x = element_blank(),\n          axis.ticks = element_blank(),\n          axis.text.y = element_blank())\n  if(log_trans) {\n    plt <- plt + scale_fill_viridis(name = \"Abund.\", trans = \"log10\")\n  } else {\n    plt <- plt + scale_fill_viridis(name = \"Abund.\")\n  }\n  return(plt)\n}\n\n\n# Plot Distatis coordinates\nplot_distatis <- function(distatis_df, consensus_df, color_label = NULL) {\n  plt <- ggplot(distatis_df, aes(Factor.1, Factor.2)) +\n    geom_density2d(bins = 10, lwd = 0.5) +\n    stat_density2d(aes(alpha = ..level..), fill = \"#2171B5\",\n                   n = 20, size = 0.01, geom =\"polygon\", bins = 20) +\n    geom_point(data =  distatis_df %>% filter(.id == 0),\n               size = 2, color = \"grey67\") +\n    geom_point(data = consensus_df, size = 3, color = \"grey17\", \n               pch = 21, aes(fill = covariate)) + \n    scale_fill_viridis(direction = 1, name = color_label) +\n    scale_alpha(range = c(0, 0.9)) +  \n    xlim(1.1*min(distatis_df$Factor.1), 1.1*max(distatis_df$Factor.1)) +\n    ylim(1.1*min(distatis_df$Factor.2), 1.1*max(distatis_df$Factor.2))   \n  return(plt)\n}\n\n\n# Plot coordinate-contoors\nplot_point_contours <- function(distatis_df, consensus_df, \n                                idx_list = NULL, color_label = NULL) {\n  if(!(\"covariate\" %in% colnames(distatis_df))) distatis_df$covariate <- NA\n  if(!(\"covariate\" %in% colnames(consensus_df))) consensus_df$covariate <- NA\n  \n  n <- nrow(consensus_df)\n  if(is.null(idx_list)) {\n    idx_list <- floor(seq(5, n-5, length.out = 3))\n  }\n  chosen_samples <- consensus_df$SampleID[consensus_df$rank_tau %in% idx_list]\n  col_levels <- consensus_df$covariate[order(consensus_df$tau)]\n  plt <- ggplot(distatis_df, aes(Factor.1, Factor.2, \n                                 group = SampleID)) +\n    stat_density2d(data = distatis_df %>% filter(SampleID %in% chosen_samples),\n                   geom =\"density2d\", bins = 10, \n                   aes(color = factor(covariate, levels = col_levels))) +\n    geom_point(data =  distatis_df %>% filter(.id == 0), \n               size = 2, color = \"grey67\") +\n    geom_point(data = consensus_df, size = 3, aes(fill = covariate),\n               pch = 21, color = \"grey77\") + \n    scale_color_viridis(direction = 1, name = color_label, discrete = T) +\n    scale_fill_viridis(direction = 1, name = color_label) +\n    xlim(1.1*min(distatis_df$Factor.1), 1.1*max(distatis_df$Factor.1)) +\n    ylim(1.1*min(distatis_df$Factor.2), 1.1*max(distatis_df$Factor.2))   \n  return(plt)\n}\n\n\n# Plot features\nplot_features_curves <- function(X, tau, feat_idx = NA, \n                                 log_transform = TRUE){\n  nFeat <- 5\n  if(!all(names(tau) %in% colnames(X))) {\n    names(tau) <- colnames(X)\n  }\n  X <- median(colSums(X)) * apply(X, 2, function(x) x/sum(x))\n  if(any(is.na(feat_idx))) {\n    X <- X[rowSums(X) > 0, ]\n    tau_cor <- apply(X, 1, function(x) cor(tau, x, method = \"spearman\"))\n    X <- X[order(-abs(tau_cor))[1:nFeat], ]\n  } else if (any(feat_idx == \"random\")){\n    X <- X[rowSums(X) > 0, ]\n    X <- X[sample(1:nrow(X), nFeat), ]\n  } else {\n    X <- X[feat_idx, ]\n  }\n  if (log_transform) {\n    X <- log10(X + 1)\n  }\n  X <- as.matrix(X)\n  X.m <- reshape2::melt(X)\n  colnames(X.m) <- c(\"Features\", \"Samples\", \"Value\")\n  X.m$tau <- tau[X.m$Samples]\n  plt <- ggplot(X.m, aes(tau, Value, color =factor(Features))) +\n    geom_smooth(aes(group = Features)) +\n    geom_point(alpha = 0.7) + \n    ylab(\"log10(X + 1)\")\n  return(plt)\n}\n\n################################################################################\n## ---- heatmaps----\n################################################################################\n#' Merge default options for a heatmap\n#' @param opts [list] (Optional) A partially specified list used to customize \n#'   ppearance in ggplot theme(). Options that are already specified will not \n#'   be changed, those that are not will be filled in with defaults.\n#' @return opts [list]  A version of opts with unspecified options filled in\n#'   with defaults.\n#' @importFrom viridis viridis\n#' @export\nmerge_heatmap_opts <- function(opts = list()) {\n  default_opts <- list(\n    \"x\" = \"col\",\n    \"y\" = \"row\",\n    \"fill_colors\" = viridis(256),\n    \"fill_breaks\" = NULL,\n    \"facet_terms\" = NULL,\n    \"facet_scales\" = \"fixed\",\n    \"facet_space\" = \"fixed\",\n    \"x_order\" = NULL,\n    \"y_order\" = NULL,\n    \"coord_ratio\" = 1,\n    \"theme_opts\" = list()\n  )\n  modifyList(default_opts, opts)\n}\n\n#' Plot matrix\n#'\n#' A simple plot of matrix entries values.\n#'\n#' @param mat [matrix/ data.frame] (Required) Data matrix to plot.\n#' @param rowIdx,colIdx [integer] (Optional) Default \\code{NULL}. \n#'     Indices of the matrix to plot.\n#' @param ... (Optional) Additional plotting options.\n#' @return p [ggplot] A ggplot heatmap object with nice defaults.\n#' @importFrom ggplot2 ggplot geom_tile aes_string scale_x_discrete\n#'   scale_fill_gradient scale_y_discrete\n#' @importFrom magrittr %>%\n#' @export\n#' @examples\n#' plot_matrix(matrix(rnorm(2000)*100, 100, 200)) \nplot_matrix <- function(mat, rowIdx = NULL, colIdx = NULL, ...) {\n  \n  opts <- merge_heatmap_opts(list(...))\n  mat <- as.matrix(mat)\n  if (!is.null(rowIdx))\n    mat <- mat[rowIdx, ]\n  if (!is.null(colIdx))\n    mat <- mat[, colIdx]\n  if(is.null(rownames(mat))) rownames(mat) <- 1:nrow(mat)\n  if(is.null(colnames(mat))) colnames(mat) <- 1:ncol(mat)\n  \n  mat_df <- mat %>%\n    reshape2::melt(\n      varnames = c(\"row\", \"col\"),\n      value.name = \"fill\"\n    )\n  if (is.null(opts$x_order)) opts$x_order <- colnames(mat)\n  if (is.null(opts$y_order)) opts$y_order <- rownames(mat)\n  mat_df[, \"col\"] <- factor(mat_df[, \"col\"], levels = opts$x_order)\n  mat_df[, \"row\"] <- factor(mat_df[, \"row\"], levels = opts$y_order)\n  \n  p <- ggplot(mat_df) + \n    geom_raster(aes(x = col, y = row, fill = fill)) + \n    scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + \n    scale_fill_gradientn(colors = opts$fill_colors, breaks = opts$fill_breaks) + \n    coord_fixed(opts$coord_ratio) + \n    theme(axis.text.x = element_text(angle = 90, hjust = 0))\n  \n  return(p)\n}\n\n\n",
    "created" : 1493015038264.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "578870557",
    "id" : "416A0E96",
    "lastKnownWriteTime" : 1493015172,
    "last_content_update" : 1493015172669,
    "path" : "~/MEGA/BIOSTATS GROUP/Projects/visBUDS/visTrajectory/R/helpers.R",
    "project_path" : "R/helpers.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}