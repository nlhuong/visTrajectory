{
    "collab_server" : "",
    "contents" : "## ----- plot functions -----\n\n#' Plot distance to kNN\n#' \n#' Computes average distance to K nearest neighbours and plots\n#' the values for every data point ordered according to\n#' coordinates computed with BUDS.\n#'\n#' @param D A dissimilarity matrix.\n#' @param tau A numeric vector of latent 1D coordinates. \n#' @param K [Optional] An integer indicating the number of \n#' points to include in the neighbourhood. If not specified \n#' one tenth of the total number of data points is used.\n#' @param color [Optional] A vector or a character string for \n#' point colors.\n#' @param color_label [Optional] A character string for the color label. \n#' @param error_bars [Optional] Whether to include error bars in the plot.\n#' @return A ggplot2 object.\n#' @export\nplot_kNN_mean_dist <- function(D, tau, K = NULL,  color = \"blue\", \n                               color_label = \"Covariate\", \n                               error_bars = FALSE) {\n  if (length(tau) != ncol(D)) {\n    stop(\"Length tau must be equal to nrow(D), i.e. the number of observations.\")\n  }\n  dkNN <- kNN_dist(D, K = K)\n  df <- data.frame(tau = tau, col = color,\n                   kNN_dist_mean = dkNN$mean, \n                   kNN_dist_sd = sqrt(dkNN$var))\n  plt <- ggplot(df, aes(x = tau, y = kNN_dist_mean, fill = col, color = col)) +\n    geom_point(size = 3, color = \"grey77\", pch = 21) + \n    scale_fill_viridis(name = color_label, discrete = !(is.numeric(color))) + \n    scale_color_viridis(name = color_label, discrete = !(is.numeric(color))) + \n    ylab(\"Distance to kNN\")\n  if(error_bars) {\n    plt <- plt + geom_errorbar(aes(ymin = kNN_dist_mean - kNN_dist_sd,\n                                   ymax = kNN_dist_mean + kNN_dist_sd))\n  }\n  return(plt)\n}\n\n\n\n#' Plot 1D latent coordinates \n#'\n#' Plot 1D latent coordinates against their ranking \n#' or supplied sample covariate data. \n#'\n#' @param tau_df A data frame with columns \"tau\", \"tau_upper\", \n#' and \"tau_lower\".\n#' @param covariate [Optional] If supplied taus coordiantes\n#' are plotted against thissample  covariate vector.\n#' @param covariate_name [Optional] The name of the covariat\n#' supplied.\n#' @param color [Optional] A vector or a character string for \n#' point colors.\n#' @param idxBigger [Optional] A vector of integers indicating which \n#' data point to highlight (make bigger).\n#' @return A ggplot2 object.\n#' @export\nplot_buds_1D <- function(tau_df, covariate = NULL, covariate_name = \"covariate\", \n                         color = \"blue\", color_label = NULL, idxBigger = NULL) {\n  if(!all(c(\"tau\", \"tau_lower\", \"tau_upper\") %in% colnames(tau_df))) {\n    stop(\"'tau_df' must have columns c('tau', 'tau_lower', 'tau_upper')\n         specified.\")\n  }\n  if(is.null(covariate)){\n    tau_df$x <- rank(tau_df$tau)\n  } else {\n    tau_df$x <- rank(covariate)\n  }\n  tau_df$color <- color\n  name_x_axis <- ifelse(is.null(covariate), \"rank(tau)\",\n                        paste0(\"rank(\", covariate_name, \")\"))\n  plt <- ggplot(tau_df, aes(x = x, y = tau, color = color)) +\n    geom_errorbar(aes(ymin = tau_lower, ymax = tau_upper), \n                  lwd = 0.7) +\n    geom_point(aes(fill = color), color = \"grey77\", pch = 21, size = 1.5) +\n    scale_color_viridis(name = color_label, discrete = (!is.numeric(color))) +\n    scale_fill_viridis(name = color_label, discrete = (!is.numeric(color))) +\n    xlab(name_x_axis) + ylab(\"tau\") \n  \n  if(!is.null(idxBigger)) {\n    plt <- plt + \n      geom_point(data = tau_df[idxBigger, ], aes(fill = color), \n                 color = \"grey77\", pch = 21, size = 3)\n  }\n  return(plt)\n}\n\n\n#' Plot data trajectory in 2 or3D\n#'\n#' Plot 2 or 3D representations of the data with PCoA\n#' of t-SNE, together with posterior data trajectories \n#' (paths) computed with BUDS.\n#'\n#' @param buds_fit A stanfit object with BUDS results.\n#' @param Y A data frame with 2D representation of the data\n#' @param eigs[Optional] A vector of eigenvalues corresponding \n#' to columns of Y.\n#' @param sample_data [Optional] A data frame with sample data.\n#' @param covariate_name [Optional] A charcter string for the column\n#' of sample_data to use for coloring points. \n#' @param path_col [Optional] A charcter string for the color\n#' of the posterior paths. Default is \"#2171B5\".\n#' @param nPaths [Optional] An integer for number of\n#' posterior paths to include. Default is 50.\n#' @param nCenters [Optional] An integer for number of\n#' data points to use for the highlighted \"mode-path\". \n#' Default is 50.\n#' @return A ggplot2 object.\n#' @export\nplot_buds_trajectory <- function(buds_fit, Y, eigs = NULL, \n                                 sample_data = NULL, \n                                 covariate_name = \"covariate\", \n                                 path_col = \"#2171B5\", nPaths = 50, \n                                 nCenters = 50){\n  nCenters <- min(nCenters, nrow(Y))\n  color_data <- \"black\"\n  if (!is.null(sample_data)){\n    if (!(covariate_name %in% colnames(sample_data))) {\n      stop(\"covariate_name is not a column in sample_data supplied.\")\n    } else {\n      color_data <- sample_data[, covariate_name]\n    }\n  }\n  # Extract tau parameter\n  fitParams <- rstan::extract(buds_fit)\n  tau_mcmc <- coda::mcmc(fitParams$tau)\n  tau_mode <- MCMCglmm::posterior.mode(tau_mcmc)\n  names(tau_mode) <- rownames(D)\n  tau_samples <- fitParams$tau\n  tau_samples <- tau_samples[sample(1:nrow(tau_samples), nPaths), ]\n  # Data to plot\n  DF <- Y\n  colnames(DF) <- paste0(\"D\", 1:ncol(Y))\n  if(!is.null(sample_data)) DF <- cbind(DF, sample_data, \n                                        color_data = color_data)\n  modeDF <- data.frame(tau_mode = tau_mode, DF)\n  modeDF <- modeDF[order(tau_mode), ]\n  # Pick a subset of samples evenly spaced alon the gradient\n  idx <- seq(1, length(tau_mode), length.out = nCenters) \n  modeDF <- modeDF[idx, ]\n  trajDF <- lapply(1:nrow(tau_samples), function(i) {\n    data.frame(trajectory = i,  Y[order(tau_samples[i, ]), ])\n  })\n  trajDF <- do.call(\"rbind\", trajDF)\n  \n  if (ncol(Y) == 2) {\n    plt <- ggplot(trajDF, aes(D1, D2)) + \n      geom_path(aes(group = trajectory), color = path_col, alpha = 0.1) +\n      geom_path(data = modeDF, color = \"grey17\", lwd = 1.2) +\n      geom_point(data = DF, color = \"grey77\", pch = 21, size = 2,\n                 aes(fill = color_data)) +\n      geom_point(data = modeDF, color = \"grey77\", pch = 21, size = 5,\n                 aes(fill = color_data)) +\n      scale_fill_viridis(name = covariate_name, \n                         discrete = !(is.numeric(color_data)))\n    if (!is.null(eigs)){\n      plt <- plt + xlab(paste0(\"PC1 [\", eigs[1], \"%]\")) +\n        ylab(paste0(\"PC2 [\", eigs[2], \"%]\")) + \n        coord_fixed(ratio = max(0.5, eigs[2]/eigs[1]))\n    }  \n  } else if (ncol(Y) > 2) {\n    plt <- plot_ly(type = 'scatter3d', mode = 'lines+markers') %>%\n      add_trace(x = modeDF$D1, y = modeDF$D2, z = modeDF$D3, \n                color = modeDF$color_data, marker = list(size = 3), \n                line = list(width = 2)) %>%\n      add_markers(x = DF$D1, y = DF$D2, z = DF$D3, marker = list(size = 1),\n                  color = DF$color_data, mode = \"markers\") \n    if (!is.null(eigs)){\n      plt <- plt %>% \n        layout(xaxis = list(title = paste0(\"PC1 [\", eigs[1], \"%]\")), \n               yaxis = list(title = paste0(\"PC2 [\", eigs[2], \"%]\")),\n               zaxis = list(title = paste0(\"PC2 [\", eigs[3], \"%]\"))) \n    }  \n  }\n  return(plt)\n}\n\n\n#' Plot DiSTATIS representation of the data\n#' \n#' Uses distatis_df data frame with configurations\n#' computed by DiSTATIS for separate dissimilarity matrix \n#' copies separetely, and a consensus_df data frame \n#' for the \"agreement\" configuration to plot the data\n#' representation with density clouds.\n#'\n#' @param distatis_df A data frame with partial configurations.\n#' @param consensus_df A data frame with a consensus configuration.\n#' consensus_df can contain a column \"covariate\" with sample data\n#' that can be used for coloring.\n#' @param color_label [Optional] A character string for the color label.\n#' @return A ggplot2 object.\n#' @export\nplot_distatis <- function(distatis_df, consensus_df, color_label = NULL) {\n  if (!(covariate %in% colnames(consensus_df))) {\n    covariate <- NA\n  }\n  plt <- ggplot(distatis_df, aes(Factor.1, Factor.2)) +\n    geom_density2d(bins = 10, lwd = 0.5) +\n    stat_density2d(aes(alpha = ..level..), fill = \"#2171B5\",\n                   n = 20, size = 0.01, geom =\"polygon\", bins = 20) +\n    geom_point(data =  distatis_df %>% filter(.id == 1),\n               size = 1.5, color = \"grey67\") +\n    geom_point(data = consensus_df, size = 2.5, color = \"grey17\", \n               pch = 21, aes(fill = covariate)) + \n    scale_fill_viridis(direction = 1, name = color_label) +\n    scale_alpha(range = c(0, 0.9)) +  \n    xlim(1.1*min(distatis_df$Factor.1), 1.1*max(distatis_df$Factor.1)) +\n    ylim(1.1*min(distatis_df$Factor.2), 1.1*max(distatis_df$Factor.2))   \n  return(plt)\n}\n\n\n#' Plot data point contours\n#' \n#' Uses distatis_df data frame with configurations\n#' computed by DiSTATIS for separate dissimilarity matrix \n#' copies separetely, and a consensus_df data frame \n#' for the \"agreement\" configuration to plot confidence\n#' contours for points selected by idx_list.\n#'\n#' @param distatis_df A data frame with partial configurations.\n#' @param consensus_df A data frame with a consensus configuration.\n#' consensus_df can contain a column \"covariate\" with sample data\n#' that can be used for coloring.\n#' @param idx_list An integer vector of selected data point indices.\n#' @param color_label [Optional] A character string for the color label.\n#' @return A ggplot2 object.\n#' @export\nplot_point_contours <- function(distatis_df, consensus_df, \n                                idx_list = NULL, color_label = NULL) {\n  if(!(rank_tau %in% colnames(consensus_df))) {\n    stop(\"consensus_df must have a column rank_tau indicating the ordering of\n         the rows.\")\n  }\n  \n  if(!(\"covariate\" %in% colnames(distatis_df))) distatis_df$covariate <- NA\n  if(!(\"covariate\" %in% colnames(consensus_df))) consensus_df$covariate <- NA\n  \n  n <- nrow(consensus_df)\n  if(is.null(idx_list)) {\n    idx_list <- floor(seq(5, n-5, length.out = 3))\n  }\n  chosen_samples <- consensus_df$SampleID[consensus_df$rank_tau %in% idx_list]\n  plt <- ggplot(distatis_df, aes(Factor.1, Factor.2, group = SampleID)) +\n    stat_density2d(data = distatis_df %>% filter(SampleID %in% chosen_samples),\n                   aes(color = covariate),\n                   geom =\"density2d\", bins = 10) +\n    geom_point(data =  distatis_df %>% filter(.id == 1), \n               size = 1.5, color = \"grey67\") +\n    geom_point(data = consensus_df, size = 3, aes(color = covariate)) + \n    scale_color_viridis(direction = 1, name = color_label, \n                        discrete = !is.numeric(distatis_df$covariate)) +\n    xlim(1.1*min(distatis_df$Factor.1), 1.1*max(distatis_df$Factor.1)) +\n    ylim(1.1*min(distatis_df$Factor.2), 1.1*max(distatis_df$Factor.2))   \n  return(plt)\n}\n\n\n#' Plot features\n#' \n#' Plot feature trends along the estimated ordering\n#' and include smoothing curves.\n#'\n#' @param X A data frame of matrix.\n#' @param tau A vector with latent 1D coordinates for data points.\n#' @param feat_idx An integer vector of selected features.\n#' @param log_trans [Optional] A boolean for whether to log \n#' transform the data before plotting. Default is FALSE. \n#' @return A ggplot2 object.\n#' @export\nplot_features_curves <- function(X, tau, feat_idx = NA, \n                                 log_trans = FALSE){\n  nFeat <- 5\n  if(!all(names(tau) %in% colnames(X))) {\n    names(tau) <- colnames(X)\n  }\n  X <- median(colSums(X)) * apply(X, 2, function(x) x/sum(x))\n  if(any(is.na(feat_idx))) {\n    X <- X[rowSums(X) > 0, ]\n    tau_cor <- apply(X, 1, function(x) cor(tau, x, method = \"spearman\"))\n    X <- X[order(-abs(tau_cor))[1:nFeat], ]\n  } else if (any(feat_idx == \"random\")){\n    X <- X[rowSums(X) > 0, ]\n    X <- X[sample(1:nrow(X), nFeat), ]\n  } else {\n    X <- X[feat_idx, ]\n  }\n  if (log_transform) {\n    X <- log10(X + 1)\n  }\n  X <- as.matrix(X)\n  X.m <- reshape2::melt(X)\n  colnames(X.m) <- c(\"Features\", \"Samples\", \"Value\")\n  X.m$tau <- tau[X.m$Samples]\n  plt <- ggplot(X.m, aes(tau, Value, color =factor(Features))) +\n    geom_smooth(aes(group = Features)) +\n    geom_point(alpha = 0.7) + \n    ylab(\"log10(X + 1)\")\n  return(plt)\n}\n\n#' Plot ordered data matrix\n#' \n#' Plot a heatmap for a data matrix where columns \n#' are reordered according to tau and rows according\n#' to either byMean or by maximum value in a window\n#' along tau.\n#' \n#'\n#' @param X A data frame of matrix.\n#' @param tau A vector with latent 1D coordinates for data points.\n#' @param log_trans [Optional] A boolean for whether to log \n#' transform the data before plotting. Default is FALSE. \n#' @param keep_features [Optional] A list of features (rows) that must be\n#' included in the heatmap.\n#' @param nfeatures The number of features to keep. Default is 500.\n#' @param byMean A boolean whether to order features by their \"mean tau\"\n#' value. If FALSE the features are ordered by maximum in a window \n#' along tau.\n#' @param window An integer for the window size. Default is 5.\n#' @param minsum A for the minimum sum for a feature in a data matrix.\n#' @return A ggplot2 object.\n#' @export\nplot_ordered_matrix <- function(X, tau, log_trans = FALSE,\n                                keep_fatures = NULL, nfeatures = 500,\n                                byMean = TRUE, window = 5, minSum = 0){\n  X <- X[rowSums(X) > minSum, ]\n  nfeatures <- min(nfeatures, 2*ncol(X))\n  if(is.null(keep_fatures)) keep_fatures <- sample(1:nrow(X), nfeatures)\n  nSamples <- ncol(X)\n  X2plot <- X[keep_fatures, order(tau)]\n  \n  normX2plot <- apply(X2plot, 2, function(x) x/sum(x))\n  \n  if(byMean) {\n    feat_loc <- normX2plot %*% tau\n  } else {\n    feat_loc <- apply(normX2plot, 1, function(x) {\n      x <- c(x)\n      y <- cumsum(x)[window:nSamples] - c(0, cumsum(x)[1:(nSamples - window)]) \n      which.max(y)\n    })\n  }\n  X2plot <- X2plot[order(feat_loc), ] \n  rownames(X2plot) <- colnames(X2plot) <- NULL\n  \n  if(log_trans) X2plot <- as.matrix(X2plot) + 1 \n  plt <- plot_matrix(X2plot) + coord_fixed() +\n    xlab(\"Samples\") + ylab(\"Features\") +\n    theme(axis.text.x = element_blank(),\n          axis.ticks = element_blank(),\n          axis.text.y = element_blank())\n  if(log_trans) {\n    plt <- plt + scale_fill_viridis(name = \"Abund.\", trans = \"log10\")\n  } else {\n    plt <- plt + scale_fill_viridis(name = \"Abund.\")\n  }\n  return(plt)\n}\n\n\n#' Merge default options for a heatmap\n#' @param opts [list] (Optional) A partially specified list used to customize \n#'   ppearance in ggplot theme(). Options that are already specified will not \n#'   be changed, those that are not will be filled in with defaults.\n#' @return opts [list]  A version of opts with unspecified options filled in\n#'   with defaults.\n#' @importFrom viridis viridis\n#' @export\nmerge_heatmap_opts <- function(opts = list()) {\n  default_opts <- list(\n    \"x\" = \"col\",\n    \"y\" = \"row\",\n    \"fill_colors\" = viridis(256),\n    \"fill_breaks\" = NULL,\n    \"facet_terms\" = NULL,\n    \"facet_scales\" = \"fixed\",\n    \"facet_space\" = \"fixed\",\n    \"x_order\" = NULL,\n    \"y_order\" = NULL,\n    \"coord_ratio\" = 1,\n    \"theme_opts\" = list()\n  )\n  modifyList(default_opts, opts)\n}\n\n#' Plot matrix\n#'\n#' A simple plot of matrix entries values.\n#'\n#' @param mat [matrix/ data.frame] (Required) Data matrix to plot.\n#' @param rowIdx,colIdx [integer] (Optional) Default \\code{NULL}. \n#'     Indices of the matrix to plot.\n#' @param ... (Optional) Additional plotting options.\n#' @return p [ggplot] A ggplot heatmap object with nice defaults.\n#' @importFrom ggplot2 ggplot geom_tile aes_string scale_x_discrete\n#'   scale_fill_gradient scale_y_discrete\n#' @importFrom magrittr %>%\n#' @export\n#' @examples\n#' plot_matrix(matrix(rnorm(2000)*100, 100, 200)) \nplot_matrix <- function(mat, rowIdx = NULL, colIdx = NULL, ...) {\n  \n  opts <- merge_heatmap_opts(list(...))\n  mat <- as.matrix(mat)\n  if (!is.null(rowIdx))\n    mat <- mat[rowIdx, ]\n  if (!is.null(colIdx))\n    mat <- mat[, colIdx]\n  if(is.null(rownames(mat))) rownames(mat) <- 1:nrow(mat)\n  if(is.null(colnames(mat))) colnames(mat) <- 1:ncol(mat)\n  \n  mat_df <- mat %>%\n    reshape2::melt(\n      varnames = c(\"row\", \"col\"),\n      value.name = \"fill\"\n    )\n  if (is.null(opts$x_order)) opts$x_order <- colnames(mat)\n  if (is.null(opts$y_order)) opts$y_order <- rownames(mat)\n  mat_df[, \"col\"] <- factor(mat_df[, \"col\"], levels = opts$x_order)\n  mat_df[, \"row\"] <- factor(mat_df[, \"row\"], levels = opts$y_order)\n  \n  p <- ggplot(mat_df) + \n    geom_raster(aes(x = col, y = row, fill = fill)) + \n    scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + \n    scale_fill_gradientn(colors = opts$fill_colors, breaks = opts$fill_breaks) + \n    coord_fixed(opts$coord_ratio) + \n    theme(axis.text.x = element_text(angle = 90, hjust = 0))\n  \n  return(p)\n}",
    "created" : 1493015093881.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "284786915",
    "id" : "504C0D2D",
    "lastKnownWriteTime" : 1492991707,
    "last_content_update" : 1492991707,
    "path" : "~/MEGA/BIOSTATS GROUP/Projects/visBUDS/R/plot_utils.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}