{
    "collab_server" : "",
    "contents" : "#' Compute pairwise correlation-based distance\n#' \n#' Pearson correlation distance for continuous\n#' data: d = (1- cor(x_i, x_j))/2 where cor(x_i, x_j)\n#' is the correlation between vector x_i and vector x_j.\n#'\n#' @param X A data matrix, e.g. gene expression\n#' @param method a character string indicating which correlation coefficient \n#' is to be computed. One of \"pearson\" (default), \"kendall\", or \n#' \"spearman\": can be abbreviated.\n#' @param scale A boolean indicating whether to normalize the\n#' columns (samples) of the data to the even sum.\n#' @param base A numeric value for the shared column sum, if scale is TRUE.  \n#' @param log_trans A boolean indicating whether to log transform\n#' the data prio to distance computation (log(X + 1)). Default is FALSE.\n#' @param log_base A number indicating base for log transformation. \n#' Default is 10.\n#' \n#' @return A dissimilarity matrix, D.\n#' @export\ncor_dist <- function(X, method = \"pearson\",\n                     scale = TRUE, base = 1e6,\n                     log_trans = TRUE, log_base = 10){\n  if(scale) { # scale samples to the same base level\n    X <- apply(X, 2, function(x) x/sum(x)*base)\n  }\n  if (log_trans) { # log-transform data\n    logexp <- log(X + 1, base = log_base) \n  }\n  # Compute correlation based distance\n  corDist <- (1 - cor(X, method = method))/2\n  D <- as.matrix(corDist) \n  return(D)\n}\n\n#' Compute Jaccard distance matrix\n#' \n#' Jaccard (or binary) distance, implemented for\n#' microbial community composition data. Include\n#' filtering options before distance computation.\n#'\n#' @param X A data matrix, e.g. microbial counnts \n#' @param min_row_prevalence An integer indicating the minimum\n#' prevalence (non-zero occurance) of a feature (species) across\n#' samples to be left for distance computation.\n#' @param min_row_sum A boolean indicating whether to normalize the\n#' columns (samples) of the data to the even sum.\n#' \n#' @return A dissimilarity matrix, D.\n#' @export\njacc_dist <- function(X, min_row_sum = 100, min_row_prevalence = 5){\n  X <- X[rowSums(X > 0) >= min_row_prevalence, ]\n  X <- X[rowSums(X) >= min_row_sum, ]\n  jaccDist <- dist(t(X), method = \"binary\")\n  D <- as.matrix(jaccDist) \n  return(D)\n}\n\n\n#' Rank based transform distances to triangular distribution\n#' \n#' Transforms the dissimularities to follow a triangular \n#' distribution on [0, 1] interval to better match distances\n#' on scalar coordinates that are approximately uniformly\n#' distributed.\n#'\n#' @param D A dissimilarity matrix.\n#' \n#' @return A transformed dissimilarity matrix, D.\n#' @export\ntransform_dist <- function(D) {\n  dvec0 <- D[lower.tri(D)]\n  dvec <- rank(dvec0)\n  dvec <- dvec/max(dvec)\n  dvec <- 1 - sqrt(1 - dvec)\n  D <- matrix(0, nrow = nrow(D), ncol = ncol(D))\n  D[lower.tri(D)] <- dvec\n  D <- D + t(D)\n  return(D)\n}\n\n\n#' k-nearest neighbours distance.\n#' \n#' Compute average distance to k-nearest neighbours\n#' for each data point from a dissimilarity matrix.\n#' This approximates the data densities around \n#' each data point.\n#' \n#' @param D A dissimilarity matrix.\n#' @param K An integer indicating the number of points \n#' to include in the neighbourhood. If not specified \n#' one tenth of the total number of data points is used.\n#' \n#' @return A list with mean distances to k-nearest \n#' neighbours and the associated variance of these\n#' k-distances for each data point.\n#' \n#' @export\nkNN_dist <- function(D, K = NULL) {\n  if (is.null(K) || is.na(K)) K <- floor(ncol(D)/10)\n  D_kSort <- apply(D, 2, function(x) {sort(x)})\n  mean <- apply(D_kSort, 2, function(x){\n    mean(x[2:(K+1)]) \n  })\n  var <- apply(D_kSort, 2, function(x){\n    var(x[2:(K+1)]) \n  })\n  return(list(mean = mean, var = var))\n}\n\n\n#' Reshape distance matrix to long format\n#' \n#' Internal function for getting distances in a long data.frame format,\n#' a format used in fit_buds function \n#'\n#' @param D A square matrix of pairwise dissimilarities\n#' @param ... Other parameters for princurve::principal.curve function.\n#' \n#' @return A data frame to be used as input data for BUDS.\nget_dist_df <- function(D, K = NULL) {\n  N <- nrow(D)\n  rownames(D) <- colnames(D) <- 1:N\n  distDF <- reshape2::melt(D)\n  colnames(distDF) <- c(\"j\", \"i\", \"d\")\n  # Keep only (n-1)n/2 distances as you assume they are symmetric\n  distDF <- distDF[distDF$i < distDF$j, ]\n  # Delete all the missing value distances\n  distDF <- distDF[!is.na(distDF$d), ]\n  # Compute average distance to kNN\n  dkNN <- kNN_dist(D, K = K)\n  distDF$i_sigma_K <- dkNN$mean[distDF$i]\n  distDF$j_sigma_K <- dkNN$mean[distDF$j]\n  distDF$max_sigma_K <- pmax(distDF$i_sigma_K, distDF$j_sigma_K)\n  distDF$min_sigma_K <- pmin(distDF$i_sigma_K, distDF$j_sigma_K)\n  return(distDF)\n}\n",
    "created" : 1493015087253.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1664406156",
    "id" : "FB1A6DE8",
    "lastKnownWriteTime" : 1492992354,
    "last_content_update" : 1492992354,
    "path" : "~/MEGA/BIOSTATS GROUP/Projects/visBUDS/R/distcomps.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}